


** Presentacion **
++ introduccion

PVM es.. blah blah blah... (ver la documentacion de los trabajos de ejemplo.. las introducciones son todas parecidas)

++ Analisis del problema

El objetivo que se nos plantea consiste en la simulación de una red P2P (peer to peer). Esto es, una red en la que cada unidad que la constituye (cada nodo) obtiene idénticos privilegios que el resto, de forma que no existan nucleos centrales, tratando de lograr la máxima descentralización.

Ese tipo de redes poseen multitud de aplicaciones, desde juegos sin servidores centrales, a conferencias de voz y video en tiempo real (como el protocolo Jingle en redes XMPP). Pero, sin duda, su aplicación más popular es la de los sistemas de compartición de archivos. Siendo a veces, en el lenguaje coloquial, sinónimo de "red p2p".



++ Solucion aportada al problema


Resultaría muy sencillo abordar el problema empleando directamente las funcionalidades de pvm para manejar grupos de procesos, de modo que se simplificase enormemente el código necesitando de sólo unas cuantas instrucciones pvm. Sin embargo, el objetivo de esta práctica es conseguir mostrar un programa que saque a relucir los problemas comunes en la comunicación entre nodos que ocurre cuando estos no se encuentran en un entorno controlado mediante una máquina virtual, y donde no es posible para el resto de nodos conocer en nada a los demás sin haber recibido referencia previa (y para ello no sería posible usar instrucciones de máquina virtual ni ningún tipo de nodo central, ya que estamos tratando una red de iguales). Es por ello, que se nos encargó la realización de la simulación del mecanismo de una red en anillo siguiendo un algoritmo diseñado para esta clase de entornos, el algoritmo de red Chord.

Por otro lado, esto presenta también diversos inconvenientes, y es que el algoritmo de Chord no... (no muestra un sistema claro de recuperación frente a la caida de nodos? ...o no lo necesita...?) y, si bien es uno de los algoritmos p2p más simples, su completa implementación en un sistema como pvm, tomaría más tiempo del que se dispone en esta asignatura. (Pues el hecho de que las instrucciones del algoritmo deban ser ideadas sin el empleo de llamadas a la máquina virtual para obtener información del resto de la red complica el código sobremanera.)

Es por ello que en el desarrollo de nuestro programa hemos decidido llegar a una situación de compromiso, suficiente para entender la mecánica de un anillo Chord, aún sin llegar a una profunda implementación de su algoritmo. 

Usando el protocolo de búsqueda de Chord, las claves de los nodos están ordenadas en un círculo. El circulo no puede tener más de 2^m nodos. El anillo puede tener claves que vayan desde 0 a 2^m-1.

Para la asignación de estas claves se suele usar lo que es conocido como hashing consistente. El algoritmo SHA-1 es la función de hashing básica para el hashing consistente. El hashing es importante en la eficiencia y robustez ya que de esto depende que tanto claves como direcciones IP estén distribuidas uniformemente y en el mismo espacio de identificación. Esto además es necesario para permitir a los nodos entrar y salir de la red sin romperla.

Cada nodo tiene un sucesor y un predecesor. El sucesor de un nodo o clave es el siguiente nodo en el anillo en sentido de las agujas del reloj, mientras que el predecesor de un nodo o clave es el siguiente nodo en el anillo en el sentido contrario. Si hubiese un nodo por cada posible clave, el sucesor del nodo 2 seria el 3, y el predecesor del nodo 1 es el nodo 0; Sin embargo, normalmente hay huecos en la secuencia, de modo que, por ejemplo, el sucesor del nodo 153 puede que sea el 167 (y los nodos del 154 al 166 no existirían); en este caso, el predecesor del nodo 167 será el nodo 153. Como el nodo sucesor (o predecesor) puede llegar a desaparecer de la red (debido a fallo o salida), cada nodo almacena un segmento entero del circulo adjaccente a él (por ejemplo, los k nodos que le preceden y los k nodos que le siguen).

One successor and predecessor are kept in a list to maintain a high probability that the successor and predecessor pointers actually point to the correct nodes after possible failure or departure of the initial successor or predecessor. (???)


  - diagramas, graficos, etc
  - clarificar los algoritmos empleados para la solucion comentando las regiones claves del codigo (pero usar el anexo para poner el código en sí)

Comentarios de los archivos de código fuente:
macros.h:
Contiene las definiciones basicas de los TAGS de los mensajes a pasar.
Principal.c:
Contiene las rutinas basicas para la creacion de los nodos del anillo Chord
Nodo.c:
Contiene el codigo basico que realizara cada nodo en el anillo Chord

++ bibliografia (no numerada)


++ anexos
  - codigo fuente del programa (padre, hijos..)
  - pruebas de ejecucion
  - otros algoritmos y documentos relativos al problema





** Otras consideraciones relativas al tipo de trabajo **
+ Ejemplos
 - Paralelizacion de algoritmos (Ej: procesado de imagen por zonas)
 - Simulacion de situaciones reales (Ej: juegos, gestion, logistica...)
 - Mejorar antiguos trabajos
+ Requerimientos
 - Paralelo, no secuencial
 - Escalable (lo mismo pa 10 que pa 100)
 - Eficiente (interesante hacer el calculo)
     E=t1p/(np*tnp) ; tnp= t1p/np = eficiencia (lo ideal E=1)

